<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Blockly Editor</title>
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
  <style>
      html,
      body,
      #root {
        height: 100%;
        margin: 0;
      }
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji",
          "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
      background: #f7f9fc;
      color: #111827;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
      #root {
        display: flex;
      }
      #blocklyDiv {
        height: 100%;
        flex: 1;
      }

    /* Toolbox panel */
    .blocklyToolboxDiv {
      background: #ffffff !important;
      border-right: 1px solid #e5e7eb;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.03), 0 2px 4px rgba(0, 0, 0, 0.06);
    }
    .blocklyTreeRow {
      height: 32px;
      border-radius: 6px;
      margin: 2px 6px;
      padding: 4px 8px;
    }
      .blocklyTreeLabel {
        color: #111827;
        font-size: 13px;
      }
      .blocklyTreeRow:hover {
        background: #f3f4f6;
      }
      .blocklyTreeSelected {
        background: #e5f3ff !important;
      }

    /* Flyout (category contents) */
      .blocklyFlyoutBackground {
        fill: #ffffff !important;
        fill-opacity: 1 !important;
      }
      .blocklyFlyoutLabelText {
        fill: #6b7280;
        font-size: 12px;
      }

    /* Workspace grid/background */
      .blocklyMainBackground {
        stroke: #e5e7eb;
        stroke-width: 1;
      }

    /* Scrollbars */
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      ::-webkit-scrollbar-thumb {
        background: #d1d5db;
        border-radius: 8px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #9ca3af;
      }
      ::-webkit-scrollbar-track {
        background: transparent;
      }

      /* Enhanced styling for if-else-if blocks */
      .blocklyBlockCanvas .blocklyDraggable[data-id*="if_else_if"] {
        border-left: 3px solid #3b82f6;
        border-radius: 8px;
      }

      .blocklyBlockCanvas
        .blocklyDraggable[data-id*="if_else_if"]
        .blocklyText {
        font-weight: 500;
      }

      /* Style for the number input field */
      .blocklyBlockCanvas
        .blocklyDraggable[data-id*="if_else_if"]
        .blocklyFieldNumber {
        background: #f0f9ff;
        border: 1px solid #3b82f6;
        border-radius: 4px;
        padding: 2px 4px;
        font-weight: bold;
        color: #1e40af;
      }

      /* Style for else-if branches */
      .blocklyBlockCanvas
        .blocklyDraggable[data-id*="if_else_if"]
        .blocklyDummyInput {
        margin: 4px 0;
      }

      .blocklyBlockCanvas
        .blocklyDraggable[data-id*="if_else_if"]
        .blocklyDummyInput
        .blocklyText {
        color: #059669;
        font-weight: 600;
      }

      /* Style for branch count label */
      .blocklyBlockCanvas
        .blocklyDraggable[data-id*="if_else_if"]
        .blocklyFieldLabel {
        background: #10b981;
        color: white;
        border-radius: 12px;
        padding: 2px 8px;
        font-weight: bold;
        font-size: 11px;
      }

      /* Style for the input section */
      .blocklyBlockCanvas
        .blocklyDraggable[data-id*="if_else_if"]
        .blocklyDummyInput:has(.blocklyFieldNumber) {
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        padding: 4px 8px;
        margin: 6px 0;
      }
  </style>
</head>
<body>
  <div id="root">
    <div id="blocklyDiv"></div>
      <xml id="toolbox" style="display: none">
        <category name="🤖" colour="#ff6b6b">
        <block type="start"></block>
        <block type="forward"></block>
        <block type="turn"></block>
        <block type="collect"></block>
        <block type="put_box"></block>
        <block type="take_box"></block>
      </category>
        <category name="🎮" colour="#4ecdc4">
        <block type="repeat_simple"></block>
        <block type="repeat_range"></block>
        <block type="if_color"></block>
          <block type="if_else_if"></block>
        <block type="while_color"></block>
      </category>
        <category name="📊" colour="#45b7d1">
        <block type="batteryCount"></block>
        <block type="getNumberBox"></block>
        <block type="warehouseCount"></block>
        <block type="math_number"></block>
          <block type="var_ref"></block>
        </category>
        <category name="🧠" colour="#a8e6cf">
          <block type="boolean_value"></block>
          <block type="check_pin_boolean"></block>
          <block type="pin_color_compare"></block>
          <block type="logical_operation"></block>
          <block type="compare"></block>
        </category>
        <category name="⚡" colour="#ff9f43">
          <block type="function_define"></block>
          <block type="function_call"></block>
      </category>
    </xml>
  </div>
  <script>
  // BEGIN inlined custom_blocks.js
      (function () {
    const C = Blockly;
    // Khai báo block "start" (màu vàng, gọn gàng, có tooltip, top-level only, single instance)
        C.Blocks["start"] = {
  init: function () {
            this.appendDummyInput().appendField("▶︎ Start"); // nhấn mạnh bắt đầu
            this.setPreviousStatement(false); // không cho nối phía trên
            this.setNextStatement(true, null); // cho phép nối phía dưới
            this.setInputsInline(true); // bố cục gọn
            this.setColour("#f5c431"); // coral sáng
            this.setTooltip(
              "Điểm bắt đầu của chương trình. Kết nối các khối ở phía dưới để chạy."
            );
            this.setHelpUrl("https://developers.google.com/blockly"); // có thể thay link docs riêng của bạn
  },

  onchange: function (e) {
    if (!this.workspace || this.isInFlyout) return;

    // 1) Đảm bảo luôn là top-level (không được gắn dưới block khác)
    if (this.getParent()) {
              this.unplug(false); // tự tách khỏi parent nếu lỡ gắn vào
              this.bumpNeighbours(); // đẩy ra nhẹ để tránh chồng lấn
    }

    // 2) Đảm bảo chỉ có 1 block "start" trong workspace
            const allStarts = this.workspace
              .getAllBlocks(false)
              .filter((b) => b.type === "start");
    if (allStarts.length > 1) {
      // Giữ lại block được tạo trước; xóa block mới hơn
      const oldest = allStarts.reduce((a, b) => (a.id < b.id ? a : b));
      if (this !== oldest) this.dispose(false);
    }
          },
};

        C.Blocks["forward"] = {
  init: function () {
            this.appendDummyInput().appendField("move forward");

    // Ô nhận số (ValueInput), cho phép Number
            this.appendValueInput("COUNT").setCheck("Number");

    this.setInputsInline(true);
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
            this.setColour("#4b92e3"); // coral sáng
            this.setTooltip("Di chuyển tiến N bước");
            this.setHelpUrl("");

    // ---- Gắn shadow math_number mặc định = 10 ----
            const shadow = Blockly.utils.xml.createElement("shadow");
            shadow.setAttribute("type", "math_number");

            const field = Blockly.utils.xml.createElement("field");
            field.setAttribute("name", "NUM");
            field.textContent = "1"; // giá trị mặc định

    shadow.appendChild(field);

            const input = this.getInput("COUNT");
    input.connection.setShadowDom(shadow);
    // Tạo lại shadow ngay khi block được khởi tạo
    input.connection.respawnShadow_();
          },
        };

        C.Blocks["turn"] = {
          init: function () {
            this.appendDummyInput()
              .appendField("turn")
              .appendField(
                new C.FieldDropdown([
                  ["right", "turnRight"],
                  ["left", "turnLeft"],
                  ["back", "turnBack"],
                ]),
                "DIR"
              );
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
            this.setColour("#4b92e3"); // coral sáng
          },
        };

        C.Blocks["collect"] = {
          init: function () {
            this.appendDummyInput().appendField("collect");
            this.appendValueInput("COUNT").setCheck("Number");
            this.appendDummyInput().appendField(
              new C.FieldDropdown([
                ["green", "green"],
                ["yellow", "yellow"],
              ]),
              "COLOR"
            );
        
        // Gắn shadow math_number mặc định = 1
            const shadow = Blockly.utils.xml.createElement("shadow");
            shadow.setAttribute("type", "math_number");

            const field = Blockly.utils.xml.createElement("field");
            field.setAttribute("name", "NUM");
            field.textContent = "1"; // giá trị mặc định

        shadow.appendChild(field);

            const input = this.getInput("COUNT");
        input.connection.setShadowDom(shadow);
        // Tạo lại shadow ngay khi block được khởi tạo
        input.connection.respawnShadow_();
        
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
            this.setColour("#4b92e3"); // coral sáng
            this.setTooltip("Collect N items of a chosen color");
            this.setHelpUrl("");
          },
        };

        C.Blocks["repeat_simple"] = {
          init: function () {
            this.appendValueInput("COUNT")
              .setCheck("Number")
              .appendField("repeat");
            this.appendStatementInput("DO").appendField("do");
            this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
            this.setColour("#ff6b36"); // teal sáng
            const shadow = Blockly.utils.xml.createElement("shadow");
            shadow.setAttribute("type", "math_number");

            const field = Blockly.utils.xml.createElement("field");
            field.setAttribute("name", "NUM");
            field.textContent = "3"; // giá trị mặc định

            shadow.appendChild(field);

            const input = this.getInput("COUNT");
            input.connection.setShadowDom(shadow);
            input.connection.respawnShadow_();
          },
        };

        C.Blocks["repeat_range"] = {
          init: function () {
        this.appendDummyInput()
              .appendField("repeat")
              .appendField(
                new C.FieldDropdown([
                  ["i", "i"],
                  ["a", "a"],
                  ["b", "b"],
                ]),
                "VAR"
              )
              .appendField(" from(");

            this.appendValueInput("FROM").setCheck("Number");
            this.appendDummyInput().appendField(" to ");
            this.appendValueInput("TO").setCheck("Number");
            this.appendDummyInput().appendField(" by ");
            this.appendValueInput("STEP").setCheck("Number");
            this.appendDummyInput().appendField(")");

            this.appendStatementInput("DO").appendField("do");

            this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
            this.setColour("#ff6b36"); // teal sáng
            this.setTooltip("for VAR in range(FROM, TO, STEP)");

            // ---- Gắn shadow mặc định cho FROM / TO / STEP ----
            function makeShadow(num) {
              const shadow = Blockly.utils.xml.createElement("shadow");
              shadow.setAttribute("type", "math_number");
              const field = Blockly.utils.xml.createElement("field");
              field.setAttribute("name", "NUM");
              field.textContent = String(num);
              shadow.appendChild(field);
              return shadow;
            }

            const from = this.getInput("FROM");
            from.connection.setShadowDom(makeShadow(0));
            from.connection.respawnShadow_();

            const to = this.getInput("TO");
            to.connection.setShadowDom(makeShadow(10));
            to.connection.respawnShadow_();

            const step = this.getInput("STEP");
            step.connection.setShadowDom(makeShadow(1));
            step.connection.respawnShadow_();
          },
        };

        C.Blocks["if_color"] = {
          init: function () {
            this.appendValueInput("CONDITION")
              .setCheck("Boolean")
              .appendField("if");
            this.appendStatementInput("THEN");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
            this.setColour("#8e44ad"); // teal sáng
          },
        };

        C.Blocks["while_color"] = {
          init: function () {
            this.appendValueInput("CONDITION")
              .setCheck("Boolean")
              .appendField("while");
            this.appendStatementInput("DO").appendField("do");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
            this.setColour("#4ecdc4"); // teal sáng
          },
        };

        // Enhanced if-else-if block with multiple else-if conditions
        // Block if/else-if với nút +/-
        // If/Else-If với nút + / - để thêm bớt nhánh; không dùng onchange để tránh xung đột khi kéo
        // If/Else-If đơn giản: 1 nút dropdown để chọn số nhánh else-if
        // If/Else-If đơn giản, dropdown chọn số nhánh, an toàn khi kéo từ flyout
        C.Blocks["if_else_if"] = {
          init: function () {
            this.elseIfCount_ = 0;
            this.maxElseIfs_ = 10;
            this._didEnterWorkspace_ = !this.isInFlyout;

            this.buildHeader_(); // tạo "if <CONDITION>" + control chọn nhánh
            this.appendStatementInput("THEN");
            this.ensureElse_(); // luôn có else
            this.ensureOrder_(); // ghim header trên cùng, else ở cuối

            this.setPreviousStatement(true);
            this.setNextStatement(true);
            this.setColour("#8e44ad"); // teal sáng
            this.setTooltip(
              "Chọn số nhánh else-if (0–10). Mỗi nhánh là một điều kiện Boolean + then."
            );
          },

          // Header: if <Boolean socket>  +  (branches: dropdown hoặc label khi ở flyout)
          buildHeader_: function () {
            if (this.getInput("CONDITION")) this.removeInput("CONDITION");
            if (this.getInput("BRANCH_CONTROL"))
              this.removeInput("BRANCH_CONTROL");

            this.appendValueInput("CONDITION")
              .setCheck("Boolean")
              .appendField("if");

            const ctrl =
              this.appendDummyInput("BRANCH_CONTROL");
            if (!this.isInFlyout) {
              const dd = new C.FieldDropdown(this.branchOptions_.bind(this));
              dd.setValue(String(this.elseIfCount_));
              dd.setValidator((val) => {
                const n = Math.max(
                  0,
                  Math.min(this.maxElseIfs_, parseInt(val || "0", 10) || 0)
                );
                this.setBranchCount_(n);
                return String(n);
              });
              ctrl.appendField(dd, "BRANCHES");
            } else {
              ctrl.appendField(
                new C.FieldLabel(String(this.elseIfCount_), "COUNT_LABEL")
              );
            }
          },

          branchOptions_: function () {
            const arr = [];
            for (let i = 0; i <= this.maxElseIfs_; i++)
              arr.push([String(i), String(i)]);
            return arr;
          },

          // Luôn giữ header ở đầu, else ở cuối
          ensureOrder_: function () {
            if (this.getInput("CONDITION") && this.getInput("THEN")) {
              this.moveInputBefore("CONDITION", "THEN");
            }
            if (this.getInput("BRANCH_CONTROL") && this.getInput("THEN")) {
              this.moveInputBefore("BRANCH_CONTROL", "THEN");
            }
            this.ensureElse_();
          },

          ensureElse_: function () {
            if (!this.getInput("ELSE"))
              this.appendStatementInput("ELSE").appendField("else");
            this.moveInputBefore("ELSE", null); // ELSE luôn cuối
          },

          // Thêm/bớt nhánh else-if theo số đã chọn
          setBranchCount_: function (n) {
            n = Math.max(0, Math.min(this.maxElseIfs_, n));
            if (n === this.elseIfCount_) {
              const lab = this.getField("COUNT_LABEL");
              if (lab) lab.setText(String(n));
              return;
            }

            // Thêm các nhánh còn thiếu
            for (let i = this.elseIfCount_ + 1; i <= n; i++) {
              this.appendValueInput("COND" + i)
                .setCheck("Boolean")
                .appendField("else if");
              this.appendStatementInput("THEN" + i);
            }
            // Xoá nhánh dư (từ cuối về)
            for (let i = this.elseIfCount_; i > n; i--) {
              if (this.getInput("COND" + i)) this.removeInput("COND" + i);
              if (this.getInput("THEN" + i)) this.removeInput("THEN" + i);
            }

            this.elseIfCount_ = n;

            const lab = this.getField("COUNT_LABEL");
            if (lab) lab.setText(String(n));
            const dd = this.getField("BRANCHES");
            if (dd && dd.getValue() !== String(n)) dd.setValue(String(n));

            this.ensureOrder_();
          },

          // Khi được kéo từ flyout sang workspace: rebuild header để hiện dropdown, rồi ghim lại thứ tự
          onchange: function () {
            if (!this.workspace) return;
            if (!this._didEnterWorkspace_ && !this.isInFlyout) {
              this._didEnterWorkspace_ = true;
              this.buildHeader_();
              this.ensureOrder_();
              const dd = this.getField("BRANCHES");
              if (dd && dd.getValue() !== String(this.elseIfCount_))
                dd.setValue(String(this.elseIfCount_));
            }
          },

          // Lưu/khôi phục số nhánh
          mutationToDom: function () {
            const m = C.utils.xml.createElement("mutation");
            m.setAttribute("elseif", String(this.elseIfCount_));
            return m;
          },
          domToMutation: function (xml) {
            const n = Math.max(
              0,
              Math.min(
                this.maxElseIfs_,
                parseInt(xml.getAttribute("elseif") || "0", 10) || 0
              )
            );
            this.buildHeader_(); // đảm bảo dropdown hiện ở workspace
            this.setBranchCount_(n); // tạo lại các COND/THEN
            this.ensureOrder_();
          },
        };

        C; // put_box với shadow số mặc định = 1
        C.Blocks["put_box"] = {
          init: function () {
            this.appendDummyInput().appendField("put box");
            this.appendValueInput("COUNT").setCheck("Number");

            this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
            this.setColour("#ff6b6b"); // coral sáng
            this.setTooltip("Đặt N hộp");

            // Shadow mặc định: math_number = 1
            const shadow = Blockly.utils.xml.createElement("shadow");
            shadow.setAttribute("type", "math_number");
            const field = Blockly.utils.xml.createElement("field");
            field.setAttribute("name", "NUM");
            field.textContent = "1";
            shadow.appendChild(field);

            const input = this.getInput("COUNT");
            input.connection.setShadowDom(shadow);
            input.connection.respawnShadow_();
          },
        };

        // take_box với shadow số mặc định = 1
        C.Blocks["take_box"] = {
          init: function () {
            this.appendDummyInput().appendField("take box");
            this.appendValueInput("COUNT").setCheck("Number");

            this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
            this.setColour("#ff6b6b"); // coral sáng
            this.setTooltip("Lấy N hộp");

            // Shadow mặc định: math_number = 1
            const shadow = Blockly.utils.xml.createElement("shadow");
            shadow.setAttribute("type", "math_number");
            const field = Blockly.utils.xml.createElement("field");
            field.setAttribute("name", "NUM");
            field.textContent = "1";
            shadow.appendChild(field);

            const input = this.getInput("COUNT");
            input.connection.setShadowDom(shadow);
            input.connection.respawnShadow_();
          },
        };

        C.Blocks["batteryCount"] = {
          init: function () {
            this.appendDummyInput().appendField("batteryCount");
            this.setOutput(true, "Number");
            this.setColour("#45b7d1"); // blue sáng
          },
        };
        C.Blocks["getNumberBox"] = {
          init: function () {
            this.appendDummyInput().appendField("getNumberBox");
            this.setOutput(true, "Number");
            this.setColour("#45b7d1"); // blue sáng
          },
        };
        C.Blocks["warehouseCount"] = {
          init: function () {
            this.appendDummyInput().appendField("warehouseCount");
            this.setOutput(true, "Number");
            this.setColour("#45b7d1"); // blue sáng
          },
        };


        // Boolean literal block (true/false in one block)
        C.Blocks["boolean_value"] = {
          init: function () {
            this.appendDummyInput().appendField(
              new C.FieldDropdown([
                ["true", "TRUE"],
                ["false", "FALSE"],
              ]),
              "VALUE"
            );
            this.setOutput(true, "Boolean");
            this.setColour("#9b27b0"); // mint sáng
            this.setTooltip("Boolean true/false value");
          },
        };

        // Pin color check block for boolean conditions
        C.Blocks["check_pin_boolean"] = {
          init: function () {
            this.appendDummyInput()
              .appendField("pin is")
              .appendField(
                new C.FieldDropdown([
                  ["🟢 green", "green"],
                  ["🔴 red", "red"],
                  ["🟡 yellow", "yellow"],
                ]),
                "COLOR"
              );
            this.setOutput(true, "Boolean");
            this.setColour("#9b27b0"); // mint sáng
            this.setTooltip("Check if pin is a specific color");
            this.setHelpUrl("");
          },
        };

        // Pin color comparison block
        C.Blocks["pin_color_compare"] = {
          init: function () {
            this.appendDummyInput()
              .appendField("pin color")
              .appendField(
                new C.FieldDropdown([
                  ["=", "EQ"],
                  ["≠", "NEQ"],
                ]),
                "OP"
              )
              .appendField(
                new C.FieldDropdown([
                  ["🟢 green", "green"],
                  ["🔴 red", "red"],
                  ["🟡 yellow", "yellow"],
                ]),
                "COLOR"
              );
            this.setOutput(true, "Boolean");
            this.setColour("#9b27b0"); // mint sáng
            this.setTooltip("Compare pin color with a specific color");
            this.setHelpUrl("");
          },
        };

        // Logical operators (AND/OR in one block)
        C.Blocks["logical_operation"] = {
          init: function () {
            this.appendValueInput("A").setCheck("Boolean");
            this.appendValueInput("B")
              .setCheck("Boolean")
              .appendField(
                new C.FieldDropdown([
                  ["and", "AND"],
                  ["or", "OR"],
                ]),
                "OP"
              );
            this.setOutput(true, "Boolean");
            this.setInputsInline(true);
            this.setColour("#9b27b0"); // mint sáng
            this.setTooltip("Logical AND/OR operation");
          },
        };

        // Variable reference block for comparison
        C.Blocks["var_ref"] = {
          init: function () {
            this.appendDummyInput().appendField(
              new C.FieldDropdown([
                ["i", "i"],
                ["a", "a"],
                ["b", "b"],
              ]),
              "VAR"
            );
            this.setOutput(true, "Number");
            this.setColour("#9b27b0"); // blue sáng
            this.setTooltip("Reference to loop variable");
          },
        };

        // Comparison operators
        C.Blocks["compare"] = {
          init: function () {
            this.appendValueInput("A").setCheck(null); // Accept any type
            this.appendValueInput("B")
              .setCheck(null) // Accept any type
              .appendField(
                new C.FieldDropdown([
                  ["=", "EQ"],
                  ["≠", "NEQ"],
                  ["<", "LT"],
                  [">", "GT"],
                  ["≤", "LTE"],
                  ["≥", "GTE"],
                ]),
                "OP"
              );
            this.setOutput(true, "Boolean");
            this.setInputsInline(true);
            this.setColour("#9b27b0"); // mint sáng
            this.setTooltip("Compare two values (numbers or strings)");
          },
        };

        // Function definition block
        C.Blocks["function_define"] = {
          init: function () {
            this.appendDummyInput()
              .appendField("📝")
              .appendField("function")
              .appendField(new C.FieldTextInput("myFunction1"), "FUNCTION_NAME");
            this.appendStatementInput("BODY").appendField("do");
            this.setPreviousStatement(false); // Functions are top-level
            this.setNextStatement(false);
            this.setColour("#ff9f43"); // orange sáng
            this.setTooltip("Define a custom function");
            this.setHelpUrl("");
          },

          onchange: function () {
            if (!this.workspace || this.isInFlyout) return;
            
            // Ensure function definitions are always top-level
            if (this.getParent()) {
              this.unplug(false);
              this.bumpNeighbours();
            }
          },
        };

        // Function call block
        C.Blocks["function_call"] = {
          init: function () {
            this.appendDummyInput()
              .appendField("🔧")
              .appendField("call")
              .appendField(new C.FieldTextInput("myFunction1"), "FUNCTION_NAME");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour("#ff9f43"); // orange sáng
            this.setTooltip("Call a custom function");
            this.setHelpUrl("");
          },
    };
  })();
  // END inlined custom_blocks.js
  </script>
  <script>
  // BEGIN inlined generators.js
      (function () {
    const gens = {};

        function numFrom(block, name) {
      const target = block.getInputTargetBlock(name);
      if (!target) return 0;
          if (target.type === "math_number")
            return Number(target.getFieldValue("NUM"));
          if (target.type === "batteryCount") return "batteryCount";
          if (target.type === "getNumberBox") return "getNumberBox";
          if (target.type === "warehouseCount") return "warehouseCount";
          if (target.type === "var_ref") return target.getFieldValue("VAR");
      return 0;
    }

        // Helper function to convert condition nodes to Python expressions
        function condToPy(cond) {
          if (!cond) return "True";
          switch (cond.type) {
            case "condition":
              return `${cond.function}()`;
            case "value":
              return `"${cond.value}"`;
            case "boolean":
              return cond.value ? "True" : "False";
            case "logical":
              const leftPy = condToPy(cond.left);
              const rightPy = condToPy(cond.right);
              const op = cond.operator === "AND" ? " and " : " or ";
              return `(${leftPy}${op}${rightPy})`;
            case "compare":
              const leftVal = typeof cond.left === "string" ? `"${cond.left}"` : JSON.stringify(cond.left);
              const rightVal = typeof cond.right === "string" ? `"${cond.right}"` : JSON.stringify(cond.right);
              const operators = {
                EQ: " == ",
                NEQ: " != ",
                LT: " < ",
                GT: " > ",
                LTE: " <= ",
                GTE: " >= "
              };
              return `(${leftVal}${operators[cond.operator] || " == "}${rightVal})`;
            default:
              return "True";
          }
        }

        function nodeStart(block) {
          return { type: "start" };
        }
        function nodeForward(block) {
          return { type: "forward", count: numFrom(block, "COUNT") };
        }
        function nodeTurn(block) {
          return { type: block.getFieldValue("DIR") };
        }
        function nodeCollect(block) {
          return {
            type: "collect",
            color: block.getFieldValue("COLOR"),
            count: numFrom(block, "COUNT"),
          };
        }
        function nodePut(block) {
          return { type: "putBox", count: numFrom(block, "COUNT") };
        }
        function nodeTake(block) {
          return { type: "takeBox", count: numFrom(block, "COUNT") };
        }
        function nodeRepeat(block) {
          const condition = block.getInputTargetBlock("CONDITION");
          return {
            type: "repeat",
            count: numFrom(block, "COUNT"),
            condition: condition ? blockToNode(condition) : null,
            body: statementToList(block, "DO"),
          };
        }
        function nodeRepeatRange(block) {
          const variable = block.getFieldValue("VAR");
          const condition = block.getInputTargetBlock("CONDITION");
          return {
            type: "repeatRange",
            variable,
            from: numFrom(block, "FROM"),
            to: numFrom(block, "TO"),
            step: numFrom(block, "STEP"),
            condition: condition ? blockToNode(condition) : null,
            body: statementToList(block, "DO"),
          };
        }
        function nodeIfColor(block) {
          const condition = block.getInputTargetBlock("CONDITION");
          return {
            type: "if",
            cond: condition
              ? blockToNode(condition)
              : { type: "condition", function: "isGreen", check: true },
            then: statementToList(block, "THEN"),
          };
        }
        function nodeWhileColor(block) {
          const condition = block.getInputTargetBlock("CONDITION");
          return {
            type: "while",
            cond: condition
              ? blockToNode(condition)
              : { type: "condition", function: "isGreen", check: true },
            body: statementToList(block, "DO"),
          };
        }
        function nodeIfElseIf(block) {
          // helpers
          const toList = (name) => {
            const v = statementToList(block, name);
            if (!v) return [];
            return Array.isArray(v) ? v.filter(Boolean) : [v];
          };
          const defaultCond = {
            type: "condition",
            function: "isGreen",
            check: true,
          };
          const toNode = (b) => (b ? blockToNode(b) : defaultCond);
          const isRealBlock = (b) =>
            !!(b && !b.isShadow?.() && !b.isInsertionMarker_); // lọc shadow / marker

          const result = { type: "if_else_if", conditions: [], thens: [] };

          // 1) IF đầu
          result.conditions.push(
            toNode(block.getInputTargetBlock("CONDITION"))
          );
          result.thens.push(toList("THEN"));

          // 2) ELSE-IF: duyệt theo input thực tế
          let i = 1;
          while (block.getInput && block.getInput("CONDITION" + i)) {
            const c = block.getInputTargetBlock("CONDITION" + i);
            if (c) {
              result.conditions.push(blockToNode(c));
              result.thens.push(toList("THEN" + i));
            }
            i++;
          }

          // 3) ELSE: CHỈ thêm khi có cờ else + có block thật + list không rỗng
          const hasElseFlag =
            !!block.elseCount_ ||
            (typeof block.getFieldValue === "function" &&
              block.getFieldValue("HAS_ELSE") === "TRUE");

          const elseInput = block.getInput && block.getInput("ELSE");
          const elseTarget =
            elseInput &&
            (elseInput.connection?.targetBlock?.() ||
              block.getInputTargetBlock?.("ELSE"));

          if (hasElseFlag && isRealBlock(elseTarget)) {
            const elseList = toList("ELSE");
            if (elseList.length > 0) {
              result.else = elseList;
            }
          }

          // 4) Phòng hờ: nếu vì lý do nào đó vẫn có 'else' mà rỗng -> xoá
          if (
            "else" in result &&
            (!result.else ||
              (Array.isArray(result.else) && result.else.length === 0))
          ) {
            delete result.else;
          }

          return result;
        }

        function nodeFunctionDefine(block) {
          return {
            type: "function_define",
            name: block.getFieldValue("FUNCTION_NAME") || "myFunction1",
            body: statementToList(block, "BODY")
          };
        }

        function nodeFunctionCall(block) {
          return {
            type: "callFunction",
            functionName: block.getFieldValue("FUNCTION_NAME") || "myFunction1"
          };
        }

        function blockToNode(block) {
          switch (block.type) {
            case "start":
              return nodeStart(block);
            case "forward":
              return nodeForward(block);
            case "turn":
              return nodeTurn(block);
            case "collect":
              return nodeCollect(block);
            case "put_box":
              return nodePut(block);
            case "take_box":
              return nodeTake(block);
            case "repeat_simple":
              return nodeRepeat(block);
            case "repeat_range":
              return nodeRepeatRange(block);
            case "if_color":
              return nodeIfColor(block);
            case "if_else_if":
              return nodeIfElseIf(block);
            case "while_color":
              return nodeWhileColor(block);
            case "boolean_value":
              const boolValue = block.getFieldValue("VALUE");
              return { type: "boolean", value: boolValue === "TRUE" };
            case "check_pin_boolean":
              const pinColor = block.getFieldValue("COLOR");
              return { 
                type: "condition", 
                function: `is${pinColor.charAt(0).toUpperCase() + pinColor.slice(1)}`, 
                check: true 
              };
            case "pin_color_compare":
              const pinColor2 = block.getFieldValue("COLOR");
              const pinOperator = block.getFieldValue("OP");
              return {
                type: "variableComparison",
                variable: "pinColor",
                operator: pinOperator,
                value: pinColor2
              };
            case "logical_operation":
              const leftLogic = block.getInputTargetBlock("A");
              const rightLogic = block.getInputTargetBlock("B");
              const logicOp = block.getFieldValue("OP");
              return {
                type: logicOp === "AND" ? "and" : "or",
                conditions: [
                  leftLogic ? blockToNode(leftLogic) : { type: "boolean", value: false },
                  rightLogic ? blockToNode(rightLogic) : { type: "boolean", value: false }
                ]
              };
            case "var_ref":
              return { type: "variable", name: block.getFieldValue("VAR") };
            case "compare":
              const leftComp = numFrom(block, "A");
              const rightComp = numFrom(block, "B");
              const operator = block.getFieldValue("OP");
              
              // Check if comparing with battery count
              if (leftComp === "batteryCount" || rightComp === "batteryCount") {
                return {
                  type: "variableComparison",
                  variable: "batteryCount",
                  operator: operator,
                  value: leftComp === "batteryCount" ? rightComp : leftComp
                };
              }
              
              // Check if comparing with warehouse count
              if (leftComp === "warehouseCount" || rightComp === "warehouseCount") {
                return {
                  type: "variableComparison",
                  variable: "warehouseCount",
                  operator: operator,
                  value: leftComp === "warehouseCount" ? rightComp : leftComp
                };
              }
              
              // Check if comparing with number box
              if (leftComp === "getNumberBox" || rightComp === "getNumberBox") {
                return {
                  type: "variableComparison",
                  variable: "getNumberBox",
                  operator: operator,
                  value: leftComp === "getNumberBox" ? rightComp : leftComp
                };
              }
              
              // Default comparison
              return {
                type: "compare",
                operator: operator,
                left: leftComp,
                right: rightComp
              };
            case "function_define":
              return nodeFunctionDefine(block);
            case "function_call":
              return nodeFunctionCall(block);
            default:
              return null;
          }
        }

        function statementToList(block, name) {
      const target = block.getInputTargetBlock(name);
      const list = [];
      let cur = target;
      while (cur) {
        const node = blockToNode(cur);
        if (node) list.push(node);
        cur = cur.getNextBlock();
      }
      return list;
    }

        gens.toJSON = function (workspace) {
      const topBlocks = workspace.getTopBlocks(true);
      const actions = [];
          const functions = [];

          // Tách function definitions và main program
          for (const block of topBlocks) {
            if (block.type === "function_define") {
              const funcNode = blockToNode(block);
              if (funcNode) {
                functions.push({
                  name: funcNode.name,
                  body: funcNode.body || []
                });
              }
            }
          }
      
      // Tìm block start và lấy tất cả blocks được kết nối dưới nó
          const startBlock = topBlocks.find((b) => b.type === "start");
      if (startBlock) {
        // Lấy block đầu tiên được kết nối dưới start
        const firstBlock = startBlock.getNextBlock();
        if (firstBlock) {
          // Lấy tất cả blocks trong chuỗi kết nối
          let cur = firstBlock;
          while (cur) {
            const n = blockToNode(cur);
            if (n) actions.push(n);
            cur = cur.getNextBlock();
          }
        }
      } else {
            // Fallback: nếu không có start block, lấy tất cả top blocks (trừ start và functions)
        for (const b of topBlocks) {
              if (b.type !== "function_define") {
          const n = blockToNode(b);
                if (n && n.type !== "start") actions.push(n);
              }
            }
          }

          const result = { 
            version: "1.0.0", 
            programName: "program", 
            actions 
          };

          // Chỉ thêm functions nếu có
          if (functions.length > 0) {
            result.functions = functions;
          }

          return result;
        };

        gens.toPython = function (workspace) {
      const program = gens.toJSON(workspace);
          function pyVal(v) {
            return typeof v === "string" ? v : JSON.stringify(v);
          }
      const lines = [];
          function emit(nodes, indent) {
            const ind = "  ".repeat(indent);
        for (const n of nodes) {
              switch (n.type) {
            // Bỏ case 'start' vì đã lọc ở toJSON
                case "forward":
                  lines.push(ind + `forward(${pyVal(n.count)})`);
                  break;
                case "turnRight":
                  lines.push(ind + "turnRight()");
                  break;
                case "turnLeft":
                  lines.push(ind + "turnLeft()");
                  break;
                case "turnBack":
                  lines.push(ind + "turnBack()");
                  break;
                case "collect":
                  lines.push(
                    ind +
                      `collect(${pyVal(n.count)}, ${JSON.stringify(n.color)})`
                  );
                  break;
                case "putBox":
                  lines.push(ind + `putBox(${pyVal(n.count)})`);
                  break;
                case "takeBox":
                  lines.push(ind + `takeBox(${pyVal(n.count)})`);
                  break;
                case "repeat":
                  if (n.condition) {
                    lines.push(ind + `for count in range(${pyVal(n.count)}):`);
                    lines.push(ind + `  while ${condToPy(n.condition)}:`);
                    emit(n.body || [], indent + 2);
                  } else {
              lines.push(ind + `for count in range(${pyVal(n.count)}):`);
              emit(n.body || [], indent + 1);
                  }
              break;
                case "repeatRange":
                  const v = n.variable || "i";
                  lines.push(
                    ind +
                      `for ${v} in range(${pyVal(n.from)}, ${pyVal(
                        n.to
                      )}, ${pyVal(n.step)}):`
                  );
                  if (n.condition) {
                    lines.push(ind + `  while ${condToPy(n.condition)}:`);
                    emit(n.body || [], indent + 2);
                  } else {
              emit(n.body || [], indent + 1);
                  }
              break;
                case "if":
                  lines.push(ind + `if ${condToPy(n.cond)}:`);
              emit(n.then || [], indent + 1);
              break;
                case "if_else_if":
                  // Generate if condition
                  const firstCond = n.conditions[0];
                  lines.push(ind + `if ${condToPy(firstCond)}:`);
                  emit(n.thens[0] || [], indent + 1);

                  // Generate else-if conditions
                  for (let i = 1; i < n.conditions.length; i++) {
                    const cond = n.conditions[i];
                    lines.push(ind + `elif ${condToPy(cond)}:`);
                    emit(n.thens[i] || [], indent + 1);
                  }

                  // Generate else clause
                  if (n.else && n.else.length > 0) {
                    lines.push(ind + "else:");
                    emit(n.else || [], indent + 1);
                  }
                  break;
                case "while":
                  lines.push(ind + `while ${condToPy(n.cond)}:`);
              emit(n.body || [], indent + 1);
              break;
                case "callFunction":
                  lines.push(ind + `${n.functionName}()`);
                  break;
          }
        }
      }
      emit(program.actions, 0);
          return lines.join("\n");
    };

    window.generators = gens;
  })();
  // END inlined generators.js
  </script>
  <script>
      const workspace = Blockly.inject("blocklyDiv", {
        toolbox: document.getElementById("toolbox"),
      scrollbars: true,
      trashcan: true,
        renderer: "zelos",
        toolboxPosition: "start",
    });

      window.importWorkspace = function (xmlText) {
      try {
        workspace.clear();
        const dom = Blockly.Xml.textToDom(xmlText);
        Blockly.Xml.domToWorkspace(dom, workspace);
        } catch (e) {
          console.error(e);
        }
    };
      window.getWorkspaceXml = function () {
      const dom = Blockly.Xml.workspaceToDom(workspace);
      return Blockly.Xml.domToPrettyText(dom);
    };

    function postToFlutter(obj) {
        try {
          FlutterFromBlockly.postMessage(JSON.stringify(obj));
        } catch (e) {
          console.log("no channel");
        }
      }
      function onChange() {
        postToFlutter({
          type: "workspace_change",
          xml: window.getWorkspaceXml(),
        });
        const python =
          (window.generators && window.generators.toPython(workspace)) || "";
        postToFlutter({ type: "python_preview", python });
    }
    workspace.addChangeListener(onChange);

    // Add a default block to verify visibility
    try {
        const xmlText =
          '<xml xmlns="https://developers.google.com/blockly/xml"><block type="start" x="30" y="30"></block><block type="forward" x="30" y="80"><value name="COUNT"><block type="math_number"><field name="NUM">3</field></block></value></block><block type="if_color" x="30" y="130"><value name="CONDITION"><block type="check_pin_green"></block></value></block><block type="repeat_simple" x="30" y="200"><value name="COUNT"><block type="math_number"><field name="NUM">5</field></block></value><value name="CONDITION"><block type="check_pin_red"></block></value></block></xml>';
      const dom = Blockly.Xml.textToDom(xmlText);
      Blockly.Xml.domToWorkspace(dom, workspace);
      } catch (e) {
        console.log(e);
      }

    // Notify Flutter that Blockly is ready
      postToFlutter({ type: "ready" });

      window.compileNow = function () {
        const program =
          window.generators && window.generators.toJSON(workspace);
        postToFlutter({ type: "compiled_program", payload: program });
    };
  </script>
</body>
</html>
