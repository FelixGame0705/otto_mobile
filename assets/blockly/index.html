<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Blockly Editor</title>
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>
    <style>
      html,
      body,
      #root {
        height: 100%;
        margin: 0;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji",
          "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
        background: #f7f9fc;
        color: #111827;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      #root {
        display: flex;
      }
      #blocklyDiv {
        height: 100%;
        flex: 1;
      }

      /* Toolbox panel */
      .blocklyToolboxDiv {
        background: #ffffff !important;
        border-right: 1px solid #e5e7eb;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.03), 0 2px 4px rgba(0, 0, 0, 0.06);
      }
      .blocklyTreeRow {
        height: 32px;
        border-radius: 6px;
        margin: 2px 6px;
        padding: 4px 8px;
      }
      .blocklyTreeLabel {
        color: #111827;
        font-size: 13px;
      }
      .blocklyTreeRow:hover {
        background: #f3f4f6;
      }
      .blocklyTreeSelected {
        background: #e5f3ff !important;
      }

      /* Flyout (category contents) */
      .blocklyFlyoutBackground {
        fill: #ffffff !important;
        fill-opacity: 1 !important;
      }
      .blocklyFlyoutLabelText {
        fill: #6b7280;
        font-size: 12px;
      }

      /* Workspace grid/background */
      .blocklyMainBackground {
        stroke: #e5e7eb;
        stroke-width: 1;
      }

      /* Scrollbars */
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      ::-webkit-scrollbar-thumb {
        background: #d1d5db;
        border-radius: 8px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #9ca3af;
      }
      ::-webkit-scrollbar-track {
        background: transparent;
      }

      /* Enhanced styling for if-else-if blocks */
      .blocklyBlockCanvas .blocklyDraggable[data-id*="if_else_if"] {
        border-left: 3px solid #3b82f6;
        border-radius: 8px;
      }

      .blocklyBlockCanvas
        .blocklyDraggable[data-id*="if_else_if"]
        .blocklyText {
        font-weight: 500;
      }

      /* Style for the number input field */
      .blocklyBlockCanvas
        .blocklyDraggable[data-id*="if_else_if"]
        .blocklyFieldNumber {
        background: #f0f9ff;
        border: 1px solid #3b82f6;
        border-radius: 4px;
        padding: 2px 4px;
        font-weight: bold;
        color: #1e40af;
      }

      /* Style for else-if branches */
      .blocklyBlockCanvas
        .blocklyDraggable[data-id*="if_else_if"]
        .blocklyDummyInput {
        margin: 4px 0;
      }

      .blocklyBlockCanvas
        .blocklyDraggable[data-id*="if_else_if"]
        .blocklyDummyInput
        .blocklyText {
        color: #059669;
        font-weight: 600;
      }

      /* Style for branch count label */
      .blocklyBlockCanvas
        .blocklyDraggable[data-id*="if_else_if"]
        .blocklyFieldLabel {
        background: #10b981;
        color: white;
        border-radius: 12px;
        padding: 2px 8px;
        font-weight: bold;
        font-size: 11px;
      }

      /* Style for the input section */
      .blocklyBlockCanvas
        .blocklyDraggable[data-id*="if_else_if"]
        .blocklyDummyInput:has(.blocklyFieldNumber) {
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        padding: 4px 8px;
        margin: 6px 0;
      }
    </style>
  </head>
  <body>
    <div id="root">
      <div id="blocklyDiv"></div>
      <xml id="toolbox" style="display: none">
        <category name="Robot" colour="#a55">
          <block type="start"></block>
          <block type="forward"></block>
          <block type="turn"></block>
          <block type="collect"></block>
          <block type="put_box"></block>
          <block type="take_box"></block>
        </category>
        <category name="Control" colour="#5ba55b">
          <block type="repeat_simple"></block>
          <block type="repeat_range"></block>
          <block type="if_color"></block>
          <block type="if_else_if"></block>
          <block type="while_color"></block>
        </category>
        <category name="Sensors/Expr" colour="#5b80a5">
          <block type="batteryCount"></block>
          <block type="getNumberBox"></block>
          <block type="warehouseCount"></block>
          <block type="math_number"></block>
          <block type="check_pin_green"></block>
          <block type="check_pin_red"></block>
          <block type="check_pin_yellow"></block>
        </category>
      </xml>
    </div>
    <script>
      // BEGIN inlined custom_blocks.js
      (function () {
        const C = Blockly;
        // Khai báo block "start" (màu vàng, gọn gàng, có tooltip, top-level only, single instance)
        C.Blocks["start"] = {
          init: function () {
            this.appendDummyInput().appendField("▶︎ Start"); // nhấn mạnh bắt đầu
            this.setPreviousStatement(false); // không cho nối phía trên
            this.setNextStatement(true, null); // cho phép nối phía dưới
            this.setInputsInline(true); // bố cục gọn
            this.setColour(45); // vàng (hue ~60)
            this.setTooltip(
              "Điểm bắt đầu của chương trình. Kết nối các khối ở phía dưới để chạy."
            );
            this.setHelpUrl("https://developers.google.com/blockly"); // có thể thay link docs riêng của bạn
          },

          onchange: function (e) {
            if (!this.workspace || this.isInFlyout) return;

            // 1) Đảm bảo luôn là top-level (không được gắn dưới block khác)
            if (this.getParent()) {
              this.unplug(false); // tự tách khỏi parent nếu lỡ gắn vào
              this.bumpNeighbours(); // đẩy ra nhẹ để tránh chồng lấn
            }

            // 2) Đảm bảo chỉ có 1 block "start" trong workspace
            const allStarts = this.workspace
              .getAllBlocks(false)
              .filter((b) => b.type === "start");
            if (allStarts.length > 1) {
              // Giữ lại block được tạo trước; xóa block mới hơn
              const oldest = allStarts.reduce((a, b) => (a.id < b.id ? a : b));
              if (this !== oldest) this.dispose(false);
            }
          },
        };

        C.Blocks["forward"] = {
          init: function () {
            this.appendDummyInput().appendField("move forward");

            // Ô nhận số (ValueInput), cho phép Number
            this.appendValueInput("COUNT").setCheck("Number");

            this.setInputsInline(true);
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(212); // vàng
            this.setTooltip("Di chuyển tiến N bước");
            this.setHelpUrl("");

            // ---- Gắn shadow math_number mặc định = 10 ----
            const shadow = Blockly.utils.xml.createElement("shadow");
            shadow.setAttribute("type", "math_number");

            const field = Blockly.utils.xml.createElement("field");
            field.setAttribute("name", "NUM");
            field.textContent = "10"; // giá trị mặc định

            shadow.appendChild(field);

            const input = this.getInput("COUNT");
            input.connection.setShadowDom(shadow);
            // Tạo lại shadow ngay khi block được khởi tạo
            input.connection.respawnShadow_();
          },
        };

        C.Blocks["turn"] = {
          init: function () {
            this.appendDummyInput()
              .appendField("turn")
              .appendField(
                new C.FieldDropdown([
                  ["right", "turnRight"],
                  ["left", "turnLeft"],
                  ["back", "turnBack"],
                ]),
                "DIR"
              );
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(160);
          },
        };

        C.Blocks["collect"] = {
          init: function () {
            this.appendDummyInput().appendField("collect");
            this.appendValueInput("COUNT").setCheck("Number");
            this.appendDummyInput().appendField(
              new C.FieldDropdown([
                ["green", "green"],
                ["yellow", "yellow"],
              ]),
              "COLOR"
            );

            // Gắn shadow math_number mặc định = 1
            const shadow = Blockly.utils.xml.createElement("shadow");
            shadow.setAttribute("type", "math_number");

            const field = Blockly.utils.xml.createElement("field");
            field.setAttribute("name", "NUM");
            field.textContent = "1"; // giá trị mặc định

            shadow.appendChild(field);

            const input = this.getInput("COUNT");
            input.connection.setShadowDom(shadow);
            // Tạo lại shadow ngay khi block được khởi tạo
            input.connection.respawnShadow_();

            this.setInputsInline(true);
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(20);
            this.setTooltip("Collect N items of a chosen color");
            this.setHelpUrl("");
          },
        };

        C.Blocks["repeat_simple"] = {
          init: function () {
            this.appendValueInput("COUNT")
              .setCheck("Number")
              .appendField("repeat");
            this.appendStatementInput("DO").appendField("do");
            this.setInputsInline(true);
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(120);
            const shadow = Blockly.utils.xml.createElement("shadow");
            shadow.setAttribute("type", "math_number");

            const field = Blockly.utils.xml.createElement("field");
            field.setAttribute("name", "NUM");
            field.textContent = "3"; // giá trị mặc định

            shadow.appendChild(field);

            const input = this.getInput("COUNT");
            input.connection.setShadowDom(shadow);
            input.connection.respawnShadow_();
          },
        };

        C.Blocks["repeat_range"] = {
          init: function () {
            this.appendDummyInput()
              .appendField("repeat")
              .appendField(
                new C.FieldDropdown([
                  ["i", "i"],
                  ["a", "a"],
                  ["b", "b"],
                ]),
                "VAR"
              )
              .appendField(" from(");

            this.appendValueInput("FROM").setCheck("Number");
            this.appendDummyInput().appendField(" to ");
            this.appendValueInput("TO").setCheck("Number");
            this.appendDummyInput().appendField(" by ");
            this.appendValueInput("STEP").setCheck("Number");
            this.appendDummyInput().appendField(")");

            this.appendStatementInput("DO").appendField("do");

            this.setInputsInline(true);
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(120);
            this.setTooltip("for VAR in range(FROM, TO, STEP)");

            // ---- Gắn shadow mặc định cho FROM / TO / STEP ----
            function makeShadow(num) {
              const shadow = Blockly.utils.xml.createElement("shadow");
              shadow.setAttribute("type", "math_number");
              const field = Blockly.utils.xml.createElement("field");
              field.setAttribute("name", "NUM");
              field.textContent = String(num);
              shadow.appendChild(field);
              return shadow;
            }

            const from = this.getInput("FROM");
            from.connection.setShadowDom(makeShadow(0));
            from.connection.respawnShadow_();

            const to = this.getInput("TO");
            to.connection.setShadowDom(makeShadow(10));
            to.connection.respawnShadow_();

            const step = this.getInput("STEP");
            step.connection.setShadowDom(makeShadow(1));
            step.connection.respawnShadow_();
          },
        };

        C.Blocks["if_color"] = {
          init: function () {
            this.appendValueInput("CONDITION")
              .setCheck("Boolean")
              .appendField("if");
            this.appendStatementInput("THEN").appendField("then");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(210);
          },
        };

        C.Blocks["while_color"] = {
          init: function () {
            this.appendValueInput("CONDITION")
              .setCheck("Boolean")
              .appendField("while");
            this.appendStatementInput("DO").appendField("do");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(210);
          },
        };

        // Enhanced if-else-if block with multiple else-if conditions
        // Block if/else-if với nút +/-
        // If/Else-If với nút + / - để thêm bớt nhánh; không dùng onchange để tránh xung đột khi kéo
        // If/Else-If đơn giản: 1 nút dropdown để chọn số nhánh else-if
        // If/Else-If đơn giản, dropdown chọn số nhánh, an toàn khi kéo từ flyout
        C.Blocks["if_else_if"] = {
  init: function () {
    this.elseIfCount_ = 0;
    this.maxElseIfs_ = 10;
    this._didEnterWorkspace_ = !this.isInFlyout;

    this.buildHeader_();                         // tạo "if <CONDITION>" + control chọn nhánh
    this.appendStatementInput("THEN").appendField("then");
    this.ensureElse_();                          // luôn có else
    this.ensureOrder_();                         // ghim header trên cùng, else ở cuối

    this.setPreviousStatement(true);
    this.setNextStatement(true);
    this.setColour(210);
    this.setTooltip("Chọn số nhánh else-if (0–10). Mỗi nhánh là một điều kiện Boolean + then.");
  },

  // Header: if <Boolean socket>  +  (branches: dropdown hoặc label khi ở flyout)
  buildHeader_: function () {
    if (this.getInput("CONDITION")) this.removeInput("CONDITION");
    if (this.getInput("BRANCH_CONTROL")) this.removeInput("BRANCH_CONTROL");

    this.appendValueInput("CONDITION").setCheck("Boolean").appendField("if");

    const ctrl = this.appendDummyInput("BRANCH_CONTROL").appendField("else-if: ");
    if (!this.isInFlyout) {
      const dd = new C.FieldDropdown(this.branchOptions_.bind(this));
      dd.setValue(String(this.elseIfCount_));
      dd.setValidator((val) => {
        const n = Math.max(0, Math.min(this.maxElseIfs_, parseInt(val || "0", 10) || 0));
        this.setBranchCount_(n);
        return String(n);
      });
      ctrl.appendField(dd, "BRANCHES");
    } else {
      ctrl.appendField(new C.FieldLabel(String(this.elseIfCount_), "COUNT_LABEL"));
    }
  },

  branchOptions_: function () {
    const arr = [];
    for (let i = 0; i <= this.maxElseIfs_; i++) arr.push([String(i), String(i)]);
    return arr;
  },

  // Luôn giữ header ở đầu, else ở cuối
  ensureOrder_: function () {
    if (this.getInput("CONDITION") && this.getInput("THEN")) {
      this.moveInputBefore("CONDITION", "THEN");
    }
    if (this.getInput("BRANCH_CONTROL") && this.getInput("THEN")) {
      this.moveInputBefore("BRANCH_CONTROL", "THEN");
    }
    this.ensureElse_();
  },

  ensureElse_: function () {
    if (!this.getInput("ELSE")) this.appendStatementInput("ELSE").appendField("else");
    this.moveInputBefore("ELSE", null); // ELSE luôn cuối
  },

  // Thêm/bớt nhánh else-if theo số đã chọn
  setBranchCount_: function (n) {
    n = Math.max(0, Math.min(this.maxElseIfs_, n));
    if (n === this.elseIfCount_) {
      const lab = this.getField("COUNT_LABEL");
      if (lab) lab.setText(String(n));
      return;
    }

    // Thêm các nhánh còn thiếu
    for (let i = this.elseIfCount_ + 1; i <= n; i++) {
      this.appendValueInput("COND" + i).setCheck("Boolean").appendField("else if");
      this.appendStatementInput("THEN" + i).appendField("then");
    }
    // Xoá nhánh dư (từ cuối về)
    for (let i = this.elseIfCount_; i > n; i--) {
      if (this.getInput("COND" + i)) this.removeInput("COND" + i);
      if (this.getInput("THEN" + i)) this.removeInput("THEN" + i);
    }

    this.elseIfCount_ = n;

    const lab = this.getField("COUNT_LABEL");
    if (lab) lab.setText(String(n));
    const dd = this.getField("BRANCHES");
    if (dd && dd.getValue() !== String(n)) dd.setValue(String(n));

    this.ensureOrder_();
  },

  // Khi được kéo từ flyout sang workspace: rebuild header để hiện dropdown, rồi ghim lại thứ tự
  onchange: function () {
    if (!this.workspace) return;
    if (!this._didEnterWorkspace_ && !this.isInFlyout) {
      this._didEnterWorkspace_ = true;
      this.buildHeader_();
      this.ensureOrder_();
      const dd = this.getField("BRANCHES");
      if (dd && dd.getValue() !== String(this.elseIfCount_)) dd.setValue(String(this.elseIfCount_));
    }
  },

  // Lưu/khôi phục số nhánh
  mutationToDom: function () {
    const m = C.utils.xml.createElement("mutation");
    m.setAttribute("elseif", String(this.elseIfCount_));
    return m;
  },
  domToMutation: function (xml) {
    const n = Math.max(0, Math.min(this.maxElseIfs_, parseInt(xml.getAttribute("elseif") || "0", 10) || 0));
    this.buildHeader_();        // đảm bảo dropdown hiện ở workspace
    this.setBranchCount_(n);    // tạo lại các COND/THEN
    this.ensureOrder_();
  }
};


        C; // put_box với shadow số mặc định = 1
        C.Blocks["put_box"] = {
          init: function () {
            this.appendDummyInput().appendField("put box");
            this.appendValueInput("COUNT")
              .setCheck("Number");

            this.setInputsInline(true);
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(20);
            this.setTooltip("Đặt N hộp");

            // Shadow mặc định: math_number = 1
            const shadow = Blockly.utils.xml.createElement("shadow");
            shadow.setAttribute("type", "math_number");
            const field = Blockly.utils.xml.createElement("field");
            field.setAttribute("name", "NUM");
            field.textContent = "1";
            shadow.appendChild(field);

            const input = this.getInput("COUNT");
            input.connection.setShadowDom(shadow);
            input.connection.respawnShadow_();
          },
        };

        // take_box với shadow số mặc định = 1
        C.Blocks["take_box"] = {
          init: function () {
            this.appendDummyInput().appendField("take box");
            this.appendValueInput("COUNT")
              .setCheck("Number");

            this.setInputsInline(true);
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(20);
            this.setTooltip("Lấy N hộp");

            // Shadow mặc định: math_number = 1
            const shadow = Blockly.utils.xml.createElement("shadow");
            shadow.setAttribute("type", "math_number");
            const field = Blockly.utils.xml.createElement("field");
            field.setAttribute("name", "NUM");
            field.textContent = "1";
            shadow.appendChild(field);

            const input = this.getInput("COUNT");
            input.connection.setShadowDom(shadow);
            input.connection.respawnShadow_();
          },
        };

        C.Blocks["batteryCount"] = {
          init: function () {
            this.appendDummyInput().appendField("batteryCount");
            this.setOutput(true, "Number");
            this.setColour(230);
          },
        };
        C.Blocks["getNumberBox"] = {
          init: function () {
            this.appendDummyInput().appendField("getNumberBox");
            this.setOutput(true, "Number");
            this.setColour(230);
          },
        };
        C.Blocks["warehouseCount"] = {
          init: function () {
            this.appendDummyInput().appendField("warehouseCount");
            this.setOutput(true, "Number");
            this.setColour(230);
          },
        };

        // Pin color check blocks - diamond shaped condition blocks
        C.Blocks["check_pin_green"] = {
          init: function(){
            this.appendDummyInput()
              .appendField('🔋')
              .appendField('pin is green');
            this.setOutput(true, 'Boolean');
            this.setColour(160); // Green color
            this.setTooltip('Check if the pin is green');
            this.setHelpUrl('');
          }
        };

        C.Blocks["check_pin_red"] = {
          init: function(){
            this.appendDummyInput()
              .appendField('🔋')
              .appendField('pin is red');
            this.setOutput(true, 'Boolean');
            this.setColour(20); // Red color
            this.setTooltip('Check if the pin is red');
            this.setHelpUrl('');
          }
        };

        C.Blocks["check_pin_yellow"] = {
          init: function(){
            this.appendDummyInput()
              .appendField('🔋')
              .appendField('pin is yellow');
            this.setOutput(true, 'Boolean');
            this.setColour(60); // Yellow color
            this.setTooltip('Check if the pin is yellow');
            this.setHelpUrl('');
          }
        };
      })();
      // END inlined custom_blocks.js
    </script>
    <script>
      // BEGIN inlined generators.js
      (function () {
        const gens = {};

        function numFrom(block, name) {
          const target = block.getInputTargetBlock(name);
          if (!target) return 0;
          if (target.type === "math_number")
            return Number(target.getFieldValue("NUM"));
          if (target.type === "batteryCount") return "batteryCount";
          if (target.type === "getNumberBox") return "getNumberBox";
          if (target.type === "warehouseCount") return "warehouseCount";
          return 0;
        }

        function nodeStart(block) {
          return { type: "start" };
        }
        function nodeForward(block) {
          return { type: "forward", count: numFrom(block, "COUNT") };
        }
        function nodeTurn(block) {
          return { type: block.getFieldValue("DIR") };
        }
        function nodeCollect(block) {
          return {
            type: "collect",
            color: block.getFieldValue("COLOR"),
            count: numFrom(block, "COUNT"),
          };
        }
        function nodePut(block) {
          return { type: "putBox", count: numFrom(block, "COUNT") };
        }
        function nodeTake(block) {
          return { type: "takeBox", count: numFrom(block, "COUNT") };
        }
        function nodeRepeat(block) {
          const condition = block.getInputTargetBlock("CONDITION");
          return {
            type: "repeat",
            count: numFrom(block, "COUNT"),
            condition: condition ? blockToNode(condition) : null,
            body: statementToList(block, "DO"),
          };
        }
        function nodeRepeatRange(block) {
          const variable = block.getFieldValue("VAR");
          const condition = block.getInputTargetBlock("CONDITION");
          return {
            type: "repeatRange",
            variable,
            from: numFrom(block, "FROM"),
            to: numFrom(block, "TO"),
            step: numFrom(block, "STEP"),
            condition: condition ? blockToNode(condition) : null,
            body: statementToList(block, "DO"),
          };
        }
        function nodeIfColor(block) {
          const condition = block.getInputTargetBlock("CONDITION");
          return {
            type: "if",
            cond: condition ? blockToNode(condition) : { type: "condition", function: "isGreen", check: true },
            then: statementToList(block, "THEN"),
          };
        }
        function nodeWhileColor(block) {
          const condition = block.getInputTargetBlock("CONDITION");
          return {
            type: "while",
            cond: condition ? blockToNode(condition) : { type: "condition", function: "isGreen", check: true },
            body: statementToList(block, "DO"),
          };
        }
        function nodeIfElseIf(block) {
          const condition = block.getInputTargetBlock("CONDITION");
          const result = {
            type: "if_else_if",
            conditions: [condition ? blockToNode(condition) : { type: "condition", function: "isGreen", check: true }],
            thens: [statementToList(block, "THEN")],
          };

          // Add else-if conditions based on the current count
          const elseifCount = block.elseIfCount_ || 0;
          for (let i = 1; i <= elseifCount; i++) {
            const elseifCondition = block.getInputTargetBlock("CONDITION" + i);
            if (elseifCondition) {
              result.conditions.push(blockToNode(elseifCondition));
              result.thens.push(statementToList(block, "THEN" + i));
            }
          }

          // Add else clause
          result.else = statementToList(block, "ELSE");

          return result;
        }

        function blockToNode(block) {
          switch (block.type) {
            case "start":
              return nodeStart(block);
            case "forward":
              return nodeForward(block);
            case "turn":
              return nodeTurn(block);
            case "collect":
              return nodeCollect(block);
            case "put_box":
              return nodePut(block);
            case "take_box":
              return nodeTake(block);
            case "repeat_simple":
              return nodeRepeat(block);
            case "repeat_range":
              return nodeRepeatRange(block);
            case "if_color":
              return nodeIfColor(block);
            case "if_else_if":
              return nodeIfElseIf(block);
            case "while_color":
              return nodeWhileColor(block);
            case "check_pin_green":
              return { type: "condition", function: "isGreen", check: true };
            case "check_pin_red":
              return { type: "condition", function: "isRed", check: true };
            case "check_pin_yellow":
              return { type: "condition", function: "isYellow", check: true };
            default:
              return null;
          }
        }

        function statementToList(block, name) {
          const target = block.getInputTargetBlock(name);
          const list = [];
          let cur = target;
          while (cur) {
            const node = blockToNode(cur);
            if (node) list.push(node);
            cur = cur.getNextBlock();
          }
          return list;
        }

        gens.toJSON = function (workspace) {
          const topBlocks = workspace.getTopBlocks(true);
          const actions = [];

          // Tìm block start và lấy tất cả blocks được kết nối dưới nó
          const startBlock = topBlocks.find((b) => b.type === "start");
          if (startBlock) {
            // Lấy block đầu tiên được kết nối dưới start
            const firstBlock = startBlock.getNextBlock();
            if (firstBlock) {
              // Lấy tất cả blocks trong chuỗi kết nối
              let cur = firstBlock;
              while (cur) {
                const n = blockToNode(cur);
                if (n) actions.push(n);
                cur = cur.getNextBlock();
              }
            }
          } else {
            // Fallback: nếu không có start block, lấy tất cả top blocks (trừ start)
            for (const b of topBlocks) {
              const n = blockToNode(b);
              if (n && n.type !== "start") actions.push(n);
            }
          }

          return { version: "1.0.0", programName: "program", actions };
        };

        gens.toPython = function (workspace) {
          const program = gens.toJSON(workspace);
          function pyVal(v) {
            return typeof v === "string" ? v : JSON.stringify(v);
          }
          const lines = [];
          function emit(nodes, indent) {
            const ind = "  ".repeat(indent);
            for (const n of nodes) {
              switch (n.type) {
                // Bỏ case 'start' vì đã lọc ở toJSON
                case "forward":
                  lines.push(ind + `forward(${pyVal(n.count)})`);
                  break;
                case "turnRight":
                  lines.push(ind + "turnRight()");
                  break;
                case "turnLeft":
                  lines.push(ind + "turnLeft()");
                  break;
                case "turnBack":
                  lines.push(ind + "turnBack()");
                  break;
                case "collect":
                  lines.push(
                    ind +
                      `collect(${pyVal(n.count)}, ${JSON.stringify(n.color)})`
                  );
                  break;
                case "putBox":
                  lines.push(ind + `putBox(${pyVal(n.count)})`);
                  break;
                case "takeBox":
                  lines.push(ind + `takeBox(${pyVal(n.count)})`);
                  break;
                case "repeat":
                  if (n.condition) {
                    lines.push(ind + `for count in range(${pyVal(n.count)}):`);
                    lines.push(ind + `  while ${pyVal(n.condition.function)}():`);
                    emit(n.body || [], indent + 2);
                  } else {
                    lines.push(ind + `for count in range(${pyVal(n.count)}):`);
                    emit(n.body || [], indent + 1);
                  }
                  break;
                case "repeatRange":
                  const v = n.variable || "i";
                  lines.push(
                    ind +
                      `for ${v} in range(${pyVal(n.from)}, ${pyVal(
                        n.to
                      )}, ${pyVal(n.step)}):`
                  );
                  if (n.condition) {
                    lines.push(ind + `  while ${pyVal(n.condition.function)}():`);
                    emit(n.body || [], indent + 2);
                  } else {
                    emit(n.body || [], indent + 1);
                  }
                  break;
                case "if":
                  const ifFunc = n.cond ? n.cond.function : "isGreen";
                  lines.push(ind + `if ${ifFunc}():`);
                  emit(n.then || [], indent + 1);
                  break;
                case "if_else_if":
                  // Generate if condition
                  const firstCond = n.conditions[0];
                  const firstFunc = firstCond ? firstCond.function : "isGreen";
                  lines.push(ind + `if ${firstFunc}():`);
                  emit(n.thens[0] || [], indent + 1);

                  // Generate else-if conditions
                  for (let i = 1; i < n.conditions.length; i++) {
                    const cond = n.conditions[i];
                    const func = cond ? cond.function : "isGreen";
                    lines.push(ind + `elif ${func}():`);
                    emit(n.thens[i] || [], indent + 1);
                  }

                  // Generate else clause
                  if (n.else && n.else.length > 0) {
                    lines.push(ind + "else:");
                    emit(n.else || [], indent + 1);
                  }
                  break;
                case "while":
                  const whileFunc = n.cond ? n.cond.function : "isGreen";
                  lines.push(ind + `while ${whileFunc}():`);
                  emit(n.body || [], indent + 1);
                  break;
              }
            }
          }
          emit(program.actions, 0);
          return lines.join("\n");
        };

        window.generators = gens;
      })();
      // END inlined generators.js
    </script>
    <script>
      const workspace = Blockly.inject("blocklyDiv", {
        toolbox: document.getElementById("toolbox"),
        scrollbars: true,
        trashcan: true,
        renderer: "zelos",
        toolboxPosition: "start",
      });

      window.importWorkspace = function (xmlText) {
        try {
          workspace.clear();
          const dom = Blockly.Xml.textToDom(xmlText);
          Blockly.Xml.domToWorkspace(dom, workspace);
        } catch (e) {
          console.error(e);
        }
      };
      window.getWorkspaceXml = function () {
        const dom = Blockly.Xml.workspaceToDom(workspace);
        return Blockly.Xml.domToPrettyText(dom);
      };

      function postToFlutter(obj) {
        try {
          FlutterFromBlockly.postMessage(JSON.stringify(obj));
        } catch (e) {
          console.log("no channel");
        }
      }
      function onChange() {
        postToFlutter({
          type: "workspace_change",
          xml: window.getWorkspaceXml(),
        });
        const python =
          (window.generators && window.generators.toPython(workspace)) || "";
        postToFlutter({ type: "python_preview", python });
      }
      workspace.addChangeListener(onChange);

      // Add a default block to verify visibility
      try {
        const xmlText =
          '<xml xmlns="https://developers.google.com/blockly/xml"><block type="start" x="30" y="30"></block><block type="forward" x="30" y="80"><value name="COUNT"><block type="math_number"><field name="NUM">3</field></block></value></block><block type="if_color" x="30" y="130"><value name="CONDITION"><block type="check_pin_green"></block></value></block><block type="repeat_simple" x="30" y="200"><value name="COUNT"><block type="math_number"><field name="NUM">5</field></block></value><value name="CONDITION"><block type="check_pin_red"></block></value></block></xml>';
        const dom = Blockly.Xml.textToDom(xmlText);
        Blockly.Xml.domToWorkspace(dom, workspace);
      } catch (e) {
        console.log(e);
      }

      // Notify Flutter that Blockly is ready
      postToFlutter({ type: "ready" });

      window.compileNow = function () {
        const program =
          window.generators && window.generators.toJSON(workspace);
        postToFlutter({ type: "compiled_program", payload: program });
      };
    </script>
  </body>
</html>
